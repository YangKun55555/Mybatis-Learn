<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTO Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!--当mapper文件和xml文件关联时，namespace的值需要配置为接口的全限定名称，Mybatis内部就是通过这个值来将接口和XML关联起来-->
<mapper namespace="com.young.mapper.UserMapper">
    <!--配置Java实体类属性和查询结果列的对应关系-->
    <resultMap id="userMap" type="SysUser">
        <!--property:映射到列结果的属性，Java类中对应的属性名；column：数据库中列名，或列的别名-->
        <id property="id" column="id"/>
        <result property="userName" column="user_name"/>
        <result property="userPassword" column="user_password"/>
        <result property="userEmail" column="user_email"/>
        <result property="userInfo" column="user_info"/>
        <result property="headImg" column="head_img" jdbcType="BLOB"/>
        <!--jdbcType：列对应的数据库类型，仅在插入、更新、删除操作中遇到为空的列时，需要用到这个属性
            javaType：java类的全限定名，或者一个类型别名，如果映射到一个JavaBean，则可以自动识别，如果映射到一个HashMap，则需要指定javaType
        -->
        <result property="createTime" column="create_time" jdbcType="TIMESTAMP"/>
    </resultMap>
    <!--resultType:定义查询结果的返回类型,这个时候需要select返回的字段名称和resultType指定的Java类的属性名大写一致才可以-->
    <select id="selectById" resultMap="userMap">
        select * from sys_user where id=#{id}
    </select>

    <select id="selectAll" resultMap="userMap">
        select * from sys_user
    </select>

    <select id="selectRolesByUserId" resultType="SysRole">
        select r.id,r.role_name roleName,r.enabled,r.create_by createBy,r.create_time createTime,u.user_name
        "user.userName",u.user_email "user.userEmail"
        from sys_user u
        inner join sys_user_role ur on u.id=ur.user_id
        inner join sys_role r on r.id=ur.role_id
        where u.id=#{userId}
    </select>

    <!--BLOB对应二进制数据流
        date、time、datetime对应JDBC的DATE、TIME、TIMESTAMP
    -->
    <insert id="insert">
        insert into sys_user
        (id,user_name,user_password,user_email,user_info,head_img,create_time)
        values (
        #{id},#{userName},#{userPassword},#{userEmail},#{userInfo},#{headImg,jdbcType=BLOB},#{createTime,
        jdbcType=TIMESTAMP}
        )
    </insert>

    <!--useGeneratedKeys=true:mybatis会使用JDBC的getGeneratedKeys方法获取数据库内部生成的主键
        keyProperty=id：将获取的主键值赋值给id属性
    -->
    <insert id="insert2" useGeneratedKeys="true" keyProperty="id">
        insert into sys_user
        (user_name,user_password,
        /*在insert中，列的部分增加了if条件，则values部分也要增加相同的if条件，保证完全匹配*/
        <if test="userEmail !=null and userEmail !=''">
            user_email,
        </if>
        user_info,head_img,create_time)
        values (
        #{userName},#{userPassword},
        <if test="userEmail !=null and userEmail !=''">
            #{userEmail},
        </if>
        #{userInfo},#{headImg,jdbcType=BLOB},#{createTime,
        jdbcType=TIMESTAMP}
        )
    </insert>

    <insert id="insert3">
        insert into sys_user
        (id,user_name,user_password,user_email,user_info,head_img,create_time)
        values (
        #{id},#{userName},#{userPassword},#{userEmail},#{userInfo},#{headImg,jdbcType=BLOB},#{createTime,
        jdbcType=TIMESTAMP}
        )
        <!--keyColumn：定义需要作为主键返回的数据表的列名
            keyProperty：定义主键对应的Java类中属性名
            resultType：定义主键返回时的数据类型
            order：与数据库有关，mysql是after
            last_insert_id（）：mysql用于回去数据库中最后插入数据的ID值
        -->
        <selectKey keyColumn="id" resultType="long" keyProperty="id" order="AFTER">
            SELECT last_insert_id()
        </selectKey>
    </insert>

    <update id="updateById">
        update sys_user
        set user_name=#{userName},
        user_password=#{userPassword},
        user_email=#{userEmail},
        user_info=#{userInfo},
        head_img=#{headImg,jdbcType=BLOB},
        create_time=#{createTime,jdbcType=TIMESTAMP}
        where id=#{id}
    </update>

    <delete id="deleteById">
        delete from sys_user where id=#{id}
    </delete>

    <select id="selectRolesByUserIdAndRoleEnabled" resultType="SysRole">
        select
        r.id,
        r.role_name roleName,
        r.enabled,
        r.create_by createBy,
        r.create_time createTIme
        from sys_user u
        inner join sys_user_role ur on u.id=ur.user_id
        inner join sys_role r on ur.role_id=r.id
        where u.id=#{userId} and r.enabled=#{enabled}
    </select>

    <select id="selectByUser" resultMap="userMap">
        select id,user_name,user_password,user_email,user_info,head_img,create_time
        from sys_user
        /*where 1=1 当if都不满足时，保证sql语法规范，后面使用where标签可以替代这种写法*/
        where 1=1
        <if test="userName != null and userName != ''">
            and user_name like concat('%',#{userName},'%')
        </if>
        <if test="userEmail !=null and userEmail !=''">
            and user_email =#{userEmail}
        </if>
    </select>

    <update id="updateByIdSelective">
        update sys_user
        set
          <if test="userName !=null and userName !=''">
              user_name=#{userName},
          </if>
        <if test="userPassword !=null and userPassword !=''">
            user_password=#{userPassword},
        </if>
        <if test="userEmail !=null and userEmail !=''">
            user_email=#{userEmail},
        </if>
        <if test="userInfo !=null and userInfo !=''">
            user_info=#{userInfo},
        </if>
        <if test="headImg !=null">
            head_img=#{headImg,jdbcType=BLOB},
        </if>
        <if test="createTime !=null">
            create_time=#{createTime.jdbcType=TIMESTAMP},
        </if>
        /*处理都为null或者只有一个满足时，sql规范问题，可以使用set标签来处理*/
        id=#{id}
        where id=#{id}

    </update>

    <select id="selectByIdOrUserName" resultMap="userMap">
        select *
        from sys_user
        where 1=1
        <choose>
            <when test="id!=null">
                and id=#{id}
            </when>
            <when test="userName!=null and userName!=''">
                and user_name=#{userName}
            </when>
            <otherwise>
                and 1=2;
            </otherwise>
        </choose>
    </select>
</mapper>